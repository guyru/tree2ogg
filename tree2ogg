#! /usr/bin/python
import os
import fnmatch
import subprocess
import multiprocessing
import signal
import argparse
import logging


class Tree2Ogg:
    def __init__(self, src, dst):
        self.src = src
        self.dst = dst

    def run(self, num_of_jobs):
        self._pool = SubprocessPool(num_of_jobs)

        for root, _, files in os.walk(self.src):
            flac_files = fnmatch.filter(files, "*.flac")

            if not flac_files:
                continue

            for name in flac_files:
                src_file = os.path.join(root, name)
                self._create_directories(src_file)
                self._encode_file(src_file)

            self._pool.wait()

    def _create_directories(self, filepath):
        """Create the target directories needed for converting a given file."""
        dirname = os.path.dirname(filepath)
        relative_dirname = os.path.relpath(dirname, self.src)
        dst_dirname = os.path.join(self.dst, relative_dirname)

        if not os.path.isdir(dst_dirname):
            logging.debug("Creating directory: %s", dst_dirname)
            os.makedirs(dst_dirname)

    def _encode_file(self, filepath):
        """Encode a flac file to ogg."""
        dirname, filename = os.path.split(filepath)
        name_wo_ext = os.path.splitext(filename)[0]
        target_name = name_wo_ext + '.ogg'

        rel_dir = os.path.relpath(dirname, self.src)
        target_file = os.path.join(self.dst, rel_dir, target_name)

        logging.info("Converting %s to %s", filepath, target_file)
        args = ['oggenc', '--quality', '5', '--quiet', '--output', target_file, filepath]

        self._pool.popen(args)

class SubprocessPool:
    def __init__(self, max_jobs):
        self.max_jobs = max_jobs
        if self.max_jobs <= 0:
            try:
                self.max_jobs = multiprocessing.cpu_count()
            except NotImplementedError:
                self.max_jobs = 1
        logging.debug("Set number of jobs to %d.", self.max_jobs)

        self.jobs = set()
        signal.signal(signal.SIGCHLD, self._sigchld)

    def _sigchld(self, signum, frame):
        done_jobs = set()
        for p in self.jobs:
            if p.poll() != None:
                done_jobs.add(p)

        self.jobs.difference_update(done_jobs)

    def popen(self, *args, **kwrds):
        while len(self.jobs) >= self.max_jobs:
            signal.pause()
        self.jobs.add(subprocess.Popen(*args, **kwrds))

    def wait(self):
        """Wait for all the jobs to terminate"""
        while len(self.jobs) > 0:
            signal.pause()



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("src_dir", help="source directory to transcode")
    parser.add_argument("dst_dir", help="destination directory")

    parser.add_argument("-j", "--jobs", help=("number of simultaneous encoding"
                        " process to spawn"), default=0, type=int)
    parser.add_argument('-v', '--verbose', help="be more verbose",
                        action='count', default=0)
    args = parser.parse_args()

    logging_level = logging.ERROR - args.verbose * 10
    logging.basicConfig(format="%(message)s", level=logging_level)

    Tree2Ogg(args.src_dir, args.dst_dir).run(args.jobs)
